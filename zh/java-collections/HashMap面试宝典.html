<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>（五）HashMap面试宝典 | 个人博客-郑伟陆</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="shortcut icon" type="image/x-icon" href="https://cdn.willlu.cn/favicon.ico">
    <meta name="description" content="如果没能一次成功，那就叫它 1.0 版吧">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/assets/css/0.styles.1a9fe624.css" as="style"><link rel="preload" href="/assets/js/app.fffba96d.js" as="script"><link rel="preload" href="/assets/js/2.dfd81853.js" as="script"><link rel="preload" href="/assets/js/52.a8accfce.js" as="script"><link rel="prefetch" href="/assets/js/10.973c6aec.js"><link rel="prefetch" href="/assets/js/11.0e19fd46.js"><link rel="prefetch" href="/assets/js/12.ac3b6e02.js"><link rel="prefetch" href="/assets/js/13.5e196ced.js"><link rel="prefetch" href="/assets/js/14.f2732e33.js"><link rel="prefetch" href="/assets/js/15.265961fd.js"><link rel="prefetch" href="/assets/js/16.688cccca.js"><link rel="prefetch" href="/assets/js/17.de78d99a.js"><link rel="prefetch" href="/assets/js/18.e643391e.js"><link rel="prefetch" href="/assets/js/19.a2d98eb9.js"><link rel="prefetch" href="/assets/js/20.3b44819f.js"><link rel="prefetch" href="/assets/js/21.4645479b.js"><link rel="prefetch" href="/assets/js/22.36e332dd.js"><link rel="prefetch" href="/assets/js/23.3fe50c20.js"><link rel="prefetch" href="/assets/js/24.4a4882c6.js"><link rel="prefetch" href="/assets/js/25.ff14a346.js"><link rel="prefetch" href="/assets/js/26.d3d1de60.js"><link rel="prefetch" href="/assets/js/27.3956647e.js"><link rel="prefetch" href="/assets/js/28.5b85fba8.js"><link rel="prefetch" href="/assets/js/29.7e81c206.js"><link rel="prefetch" href="/assets/js/3.661bdb6d.js"><link rel="prefetch" href="/assets/js/30.f4201393.js"><link rel="prefetch" href="/assets/js/31.20bd7c4b.js"><link rel="prefetch" href="/assets/js/32.2319c2b8.js"><link rel="prefetch" href="/assets/js/33.78d2c730.js"><link rel="prefetch" href="/assets/js/34.646132c9.js"><link rel="prefetch" href="/assets/js/35.ec82c647.js"><link rel="prefetch" href="/assets/js/36.be969767.js"><link rel="prefetch" href="/assets/js/37.f2fde86a.js"><link rel="prefetch" href="/assets/js/38.8ecdcd79.js"><link rel="prefetch" href="/assets/js/39.ba8598fc.js"><link rel="prefetch" href="/assets/js/4.4903d4ea.js"><link rel="prefetch" href="/assets/js/40.5ef975f9.js"><link rel="prefetch" href="/assets/js/41.30b51aa2.js"><link rel="prefetch" href="/assets/js/42.b7bd944e.js"><link rel="prefetch" href="/assets/js/43.2305b060.js"><link rel="prefetch" href="/assets/js/44.053c3efa.js"><link rel="prefetch" href="/assets/js/45.3f4e86c9.js"><link rel="prefetch" href="/assets/js/46.a6d68b59.js"><link rel="prefetch" href="/assets/js/47.c0621af4.js"><link rel="prefetch" href="/assets/js/48.23840de1.js"><link rel="prefetch" href="/assets/js/49.f45d553c.js"><link rel="prefetch" href="/assets/js/5.4e0d5a34.js"><link rel="prefetch" href="/assets/js/50.b2e86925.js"><link rel="prefetch" href="/assets/js/51.e3fe0d25.js"><link rel="prefetch" href="/assets/js/53.cbcba151.js"><link rel="prefetch" href="/assets/js/54.a6ce2c8b.js"><link rel="prefetch" href="/assets/js/55.9b999980.js"><link rel="prefetch" href="/assets/js/56.730551f8.js"><link rel="prefetch" href="/assets/js/57.78eca7ce.js"><link rel="prefetch" href="/assets/js/58.548c6205.js"><link rel="prefetch" href="/assets/js/59.9742b4e2.js"><link rel="prefetch" href="/assets/js/6.06d851e0.js"><link rel="prefetch" href="/assets/js/60.2c52c2e9.js"><link rel="prefetch" href="/assets/js/61.1e0c4ec2.js"><link rel="prefetch" href="/assets/js/62.6586b9c8.js"><link rel="prefetch" href="/assets/js/63.16442123.js"><link rel="prefetch" href="/assets/js/64.a37e0e38.js"><link rel="prefetch" href="/assets/js/65.c98a1547.js"><link rel="prefetch" href="/assets/js/66.c895a248.js"><link rel="prefetch" href="/assets/js/67.0a295129.js"><link rel="prefetch" href="/assets/js/68.e031426d.js"><link rel="prefetch" href="/assets/js/69.1037e666.js"><link rel="prefetch" href="/assets/js/7.a67ed9e2.js"><link rel="prefetch" href="/assets/js/70.b3563e10.js"><link rel="prefetch" href="/assets/js/71.ee100bf0.js"><link rel="prefetch" href="/assets/js/72.5147e5df.js"><link rel="prefetch" href="/assets/js/73.609f5a80.js"><link rel="prefetch" href="/assets/js/74.a2b0043d.js"><link rel="prefetch" href="/assets/js/8.e57a2e26.js"><link rel="prefetch" href="/assets/js/9.a105a76e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a9fe624.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">个人博客-郑伟陆</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/zh/guide/">
          指南
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/zh/java/">
          Java宝典
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          在线文档
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          技术框架
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          微服务网格化
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          在线工具
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="https://old-blog.willlu.cn/" target="_blank">
          切换旧版本
          <i aria-label="icon: link" class="anticon anticon-link"><svg viewBox="64 64 896 896" focusable="false" data-icon="link" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M574 665.4a8.03 8.03 0 0 0-11.3 0L446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3l-39.8-39.8a8.03 8.03 0 0 0-11.3 0L191.4 526.5c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3L574 665.4zm258.6-474c-84.6-84.6-221.5-84.6-306 0L410.3 307.6a8.03 8.03 0 0 0 0 11.3l39.7 39.7c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204L665.3 562.6a8.03 8.03 0 0 0 0 11.3l39.8 39.8c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c84.5-84.6 84.5-221.5 0-306.1zM610.1 372.3a8.03 8.03 0 0 0-11.3 0L372.3 598.7a8.03 8.03 0 0 0 0 11.3l39.6 39.6c3.1 3.1 8.2 3.1 11.3 0l226.4-226.4c3.1-3.1 3.1-8.2 0-11.3l-39.5-39.6z"></path></svg></i></a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/zh/changelog/">
          Changelog
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <a href="https://sc.willlu.cn/" target="_blank" rel="noopener noreferrer" class="repo-link"><i aria-label="icon: github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></i></a></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java集合框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zh/java-collections/剖析常见问题之Java集合框架.html" class="sidebar-link">（一）剖析常见问题之Java集合框架</a></li><li><a href="/zh/java-collections/ArrayList 扩容机制.html" class="sidebar-link">（二）ArrayList 扩容机制</a></li><li><a href="/zh/java-collections/ArrayList 源码解析.html" class="sidebar-link">（三）ArrayList 源码解析</a></li><li><a href="/zh/java-collections/Synchronized四种锁状态的升级.html" class="sidebar-link">（四）Synchronized四种锁状态的升级</a></li><li><a href="/zh/java-collections/HashMap面试宝典.html" class="active sidebar-link">（五）HashMap面试宝典</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_1：hashmap-的数据结构？" class="sidebar-link">1：HashMap 的数据结构？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_2：hashmap-的工作原理？" class="sidebar-link">2：HashMap 的工作原理？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_3-当两个对象的-hashcode-相同会发生什么？" class="sidebar-link">3.当两个对象的 hashCode 相同会发生什么？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_4-你知道-hash-的实现吗？为什么要这样实现？" class="sidebar-link">4.你知道 hash 的实现吗？为什么要这样实现？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_5-为什么要用异或运算符？" class="sidebar-link">5.为什么要用异或运算符？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_6-hashmap-的-table-的容量如何确定？loadfactor-是什么？该容量如何变化？这种变化会带来什么问题？" class="sidebar-link">6.HashMap 的 table 的容量如何确定？loadFactor 是什么？该容量如何变化？这种变化会带来什么问题？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_7-hashmap中put方法的过程？" class="sidebar-link">7.HashMap中put方法的过程？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_8-数组扩容的过程？" class="sidebar-link">8.数组扩容的过程？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_9-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="sidebar-link">9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_10-说说你对红黑树的见解？" class="sidebar-link">10.说说你对红黑树的见解？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_11-jdk8中对hashmap做了哪些改变？" class="sidebar-link">11.jdk8中对HashMap做了哪些改变？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_12-hashmap，linkedhashmap，treemap-有什么区别？" class="sidebar-link">12.HashMap，LinkedHashMap，TreeMap 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_13-hashmap-treemap-linkedhashmap-使用场景？" class="sidebar-link">13.HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_14-hashmap-和-hashtable-有什么区别？" class="sidebar-link">14.HashMap 和 HashTable 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_19-concurrenthashmap-在-jdk-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-reentrantlock？" class="sidebar-link">19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_20-concurrenthashmap-简单介绍？" class="sidebar-link">20.ConcurrentHashMap 简单介绍？</a></li><li class="sidebar-sub-header"><a href="/zh/java-collections/HashMap面试宝典.html#_21-concurrenthashmap-的并发度是什么？" class="sidebar-link">21.ConcurrentHashMap 的并发度是什么？</a></li></ul></li></ul></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="hashmap面试宝典"><a href="#hashmap面试宝典" class="header-anchor">#</a> HashMap面试宝典</h1> <h2 id="_1：hashmap-的数据结构？"><a href="#_1：hashmap-的数据结构？" class="header-anchor">#</a> 1：HashMap 的数据结构？</h2> <p>A：哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过 8 时，链表转换为红黑树。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>\<span class="token punctuation">[</span>\<span class="token punctuation">]</span> table<span class="token punctuation">;</span>
</code></pre></div><h2 id="_2：hashmap-的工作原理？"><a href="#_2：hashmap-的工作原理？" class="header-anchor">#</a> 2：HashMap 的工作原理？</h2> <p>HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put &amp; get 方法存储和获取。
存储对象时，将 K/V 键值传给 put() 方法：</p> <ol><li>调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</li> <li>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；</li> <li>K 的 hash 值在 HashMap 中的情况</li> <li>i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；</li> <li>ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；</li> <li>iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</li></ol> <p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）</p> <p>获取对象时，将 K 传给 get() 方法：①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</p> <p>hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等。</p> <h2 id="_3-当两个对象的-hashcode-相同会发生什么？"><a href="#_3-当两个对象的-hashcode-相同会发生什么？" class="header-anchor">#</a> 3.当两个对象的 hashCode 相同会发生什么？</h2> <p>因为 hashCode 相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，&quot;碰撞&quot;就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。为什么要重写 hashcode 和 equals 方法？推荐看下。</p> <h2 id="_4-你知道-hash-的实现吗？为什么要这样实现？"><a href="#_4-你知道-hash-的实现吗？为什么要这样实现？" class="header-anchor">#</a> 4.你知道 hash 的实现吗？为什么要这样实现？</h2> <p>JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p> <h2 id="_5-为什么要用异或运算符？"><a href="#_5-为什么要用异或运算符？" class="header-anchor">#</a> 5.为什么要用异或运算符？</h2> <p>保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p> <h2 id="_6-hashmap-的-table-的容量如何确定？loadfactor-是什么？该容量如何变化？这种变化会带来什么问题？"><a href="#_6-hashmap-的-table-的容量如何确定？loadfactor-是什么？该容量如何变化？这种变化会带来什么问题？" class="header-anchor">#</a> 6.HashMap 的 table 的容量如何确定？loadFactor 是什么？该容量如何变化？这种变化会带来什么问题？</h2> <ol><li>table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1&lt;&lt;30；</li> <li>loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；</li> <li>扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）</li> <li>如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</li></ol> <h2 id="_7-hashmap中put方法的过程？"><a href="#_7-hashmap中put方法的过程？" class="header-anchor">#</a> 7.HashMap中put方法的过程？</h2> <p>答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；
如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
如果结点的key已经存在，则替换其value即可；
如果集合中的键值对大于12，调用resize方法进行数组扩容。”</p> <h2 id="_8-数组扩容的过程？"><a href="#_8-数组扩容的过程？" class="header-anchor">#</a> 8.数组扩容的过程？</h2> <p>创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。</p> <h2 id="_9-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#_9-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="header-anchor">#</a> 9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h2> <p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。推荐：面试问红黑树，我脸都绿了。
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p> <h2 id="_10-说说你对红黑树的见解？"><a href="#_10-说说你对红黑树的见解？" class="header-anchor">#</a> 10.说说你对红黑树的见解？</h2> <p>每个节点非红即黑
根节点总是黑色的
如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
每个叶子节点都是黑色的空节点（NIL节点）
从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</p> <h2 id="_11-jdk8中对hashmap做了哪些改变？"><a href="#_11-jdk8中对hashmap做了哪些改变？" class="header-anchor">#</a> 11.jdk8中对HashMap做了哪些改变？</h2> <p>在java 1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
发生hash碰撞时，java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入
在java 1.8中，Entry被Node替代(换了一个马甲。</p> <h2 id="_12-hashmap，linkedhashmap，treemap-有什么区别？"><a href="#_12-hashmap，linkedhashmap，treemap-有什么区别？" class="header-anchor">#</a> 12.HashMap，LinkedHashMap，TreeMap 有什么区别？</h2> <p>HashMap 参考其他问题；
LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；
TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p> <h2 id="_13-hashmap-treemap-linkedhashmap-使用场景？"><a href="#_13-hashmap-treemap-linkedhashmap-使用场景？" class="header-anchor">#</a> 13.HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？</h2> <p>一般情况下，使用最多的是 HashMap。
HashMap：在 Map 中插入、删除和定位元素时；
TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；
LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。</p> <h2 id="_14-hashmap-和-hashtable-有什么区别？"><a href="#_14-hashmap-和-hashtable-有什么区别？" class="header-anchor">#</a> 14.HashMap 和 HashTable 有什么区别？</h2> <ol><li>HashMap 是线程不安全的，HashTable 是线程安全的；</li> <li>由于线程安全，所以 HashTable 的效率比不上 HashMap；</li> <li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；</li> <li>HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</li> <li>HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</li></ol> <h1 id="_15-java-中的另一个线程安全的与-hashmap-极其类似的类是什么？同样是线程安全，它与-hashtable-在线程同步上有什么不同？"><a href="#_15-java-中的另一个线程安全的与-hashmap-极其类似的类是什么？同样是线程安全，它与-hashtable-在线程同步上有什么不同？" class="header-anchor">#</a> 15.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？</h1> <p>ConcurrentHashMap 类（是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）。
HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；
而针对 ConcurrentHashMap，在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了CAS（无锁算法）+ synchronized。</p> <h1 id="_16-hashmap-concurrenthashmap-的区别？"><a href="#_16-hashmap-concurrenthashmap-的区别？" class="header-anchor">#</a> 16.HashMap &amp; ConcurrentHashMap 的区别？</h1> <p>除了加锁，原理上无太大区别。另外，HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。</p> <h1 id="_17-为什么-concurrenthashmap-比-hashtable-效率要高？"><a href="#_17-为什么-concurrenthashmap-比-hashtable-效率要高？" class="header-anchor">#</a> 17.为什么 ConcurrentHashMap 比 HashTable 效率要高？</h1> <p>HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；
ConcurrentHashMap
JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。
JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结
点）（实现 Map.Entry）。锁粒度降低了。</p> <h1 id="_18-针对-concurrenthashmap-锁机制具体分析（jdk-1-7-vs-jdk-1-8）"><a href="#_18-针对-concurrenthashmap-锁机制具体分析（jdk-1-7-vs-jdk-1-8）" class="header-anchor">#</a> 18.针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）</h1> <p>JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。</p> <ol><li>Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；</li> <li>HashEntry 用来封装映射表的键-值对；</li> <li>每个桶是由若干个 HashEntry 对象链接起来的链表</li></ol> <p><img src="https://cdn.willlu.cn//image/collection/WX20200627-210620%402x.png" alt="Java集合框架图"></p> <p>JDK 1.8 中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。</p> <p><img src="https://cdn.willlu.cn//image/collection/WX20200627-210642%402x.png" alt="Java集合框架图"></p> <h2 id="_19-concurrenthashmap-在-jdk-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-reentrantlock？"><a href="#_19-concurrenthashmap-在-jdk-1-8-中，为什么要使用内置锁-synchronized-来代替重入锁-reentrantlock？" class="header-anchor">#</a> 19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</h2> <ol><li>粒度降低了；</li> <li>JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。</li> <li>在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。</li></ol> <h2 id="_20-concurrenthashmap-简单介绍？"><a href="#_20-concurrenthashmap-简单介绍？" class="header-anchor">#</a> 20.ConcurrentHashMap 简单介绍？</h2> <ol><li>重要的常量：
private transient volatile int sizeCtl;
当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；
当为 0 时，表示 table 还没有初始化；
当为其他正数时，表示初始化或者下一次进行扩容的大小。</li> <li>数据结构：
Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；
TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；
TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。</li> <li>存储对象时（put() 方法）：
如果没有初始化，就调用 initTable() 方法来进行初始化；
如果没有 hash 冲突就直接 CAS 无锁插入；
如果需要扩容，就先进行扩容；
如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历
到尾端插入，一种是红黑树就按照红黑树结构插入；
如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环
如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</li> <li>扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。
helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。</li> <li>获取对象时（get()方法）：
计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；
如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。</li></ol> <h2 id="_21-concurrenthashmap-的并发度是什么？"><a href="#_21-concurrenthashmap-的并发度是什么？" class="header-anchor">#</a> 21.ConcurrentHashMap 的并发度是什么？</h2> <p>程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。
当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2020-06-27 21:20:20</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/zh/java-collections/Synchronized四种锁状态的升级.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        （四）Synchronized四种锁状态的升级
      </a></span> <!----></p></div> </main> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.fffba96d.js" defer></script><script src="/assets/js/2.dfd81853.js" defer></script><script src="/assets/js/52.a8accfce.js" defer></script>
  </body>
</html>