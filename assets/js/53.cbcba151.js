(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{777:function(v,_,t){"use strict";t.r(_);var r=t(97),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"synchronized四种锁状态的升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized四种锁状态的升级"}},[v._v("#")]),v._v(" Synchronized四种锁状态的升级")]),v._v(" "),t("h2",{attrs:{id:"一、背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、背景"}},[v._v("#")]),v._v(" 一、背景")]),v._v(" "),t("p",[v._v("在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即加锁。并且实现的是悲观锁，在操作同步资源的时候直接先加锁。")]),v._v(" "),t("p",[v._v("加锁可以使一段代码在同一时间只有一个线程可以访问，在增加安全性的同时，牺牲掉的是程序的执行性能，所以为了在一定程度上减少获得锁和释放锁带来的性能消耗，在 jdk6 之后便引入了“偏向锁”和“轻量级锁”，所以总共有4种锁状态，级别由低到高依次为：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。这几个状态会随着竞争情况逐渐升级。")]),v._v(" "),t("p",[t("strong",[v._v("注意：锁可以升级但不能降级。")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.willlu.cn/image/bigdata/%E9%94%81%E7%8A%B6%E6%80%81.png",alt:"锁状态说明及升级图示"}})]),v._v(" "),t("p",[v._v("锁状态说明及升级图示")]),v._v(" "),t("p",[v._v("当然了，在谈这四种状态之前，我们还是有必要再简单了解下 "),t("strong",[v._v("synchronized")]),v._v(" 的原理。")]),v._v(" "),t("p",[v._v("在使用 "),t("strong",[v._v("synchronized")]),v._v(" 来同步代码块的时候，经编译后，会在代码块的起始位置插入 "),t("strong",[v._v("monitorenter指令")]),v._v(" ，在结束或异常处插入 "),t("strong",[v._v("monitorexit指令")]),v._v("。当执行到 monitorenter 指令时，将会尝试获取对象所对应的 "),t("strong",[v._v("monitor")]),v._v(" 的所有权，即尝试获得对象的锁。而 "),t("strong",[v._v("synchronized")]),v._v(" 用的锁是存放在 "),t("strong",[v._v("Java对象头")]),v._v(" 中的。")]),v._v(" "),t("p",[v._v("所以引出了两个关键词："),t("strong",[v._v("“Java 对象头”")]),v._v(" 和 "),t("strong",[v._v("“Monitor”")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"二、java-对象头和-monitor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、java-对象头和-monitor"}},[v._v("#")]),v._v(" 二、Java 对象头和 Monitor")]),v._v(" "),t("h3",{attrs:{id:"_1、java-对象头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、java-对象头"}},[v._v("#")]),v._v(" 1、Java 对象头")]),v._v(" "),t("p",[v._v("我们以 "),t("strong",[v._v("Hotspot")]),v._v(" 虚拟机为例，"),t("strong",[v._v("Hotspot")]),v._v(" 的对象头主要包括两部分数据："),t("strong",[v._v("Mark Word")]),v._v("（标记字段）、"),t("strong",[v._v("Klass Pointer")]),v._v("（类型指针）。")]),v._v(" "),t("p",[t("strong",[v._v("Mark Word")]),v._v("：默认存储对象的 "),t("strong",[v._v("HashCode")]),v._v("，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 "),t("strong",[v._v("Mark Word")]),v._v(" 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 "),t("strong",[v._v("Mark Word")]),v._v(" 里存储的数据会随着锁标志位的变化而变化。")]),v._v(" "),t("p",[t("strong",[v._v("Klass Point")]),v._v("：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。")]),v._v(" "),t("h3",{attrs:{id:"_2、monitor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、monitor"}},[v._v("#")]),v._v(" 2、Monitor")]),v._v(" "),t("p",[t("strong",[v._v("Monitor")]),v._v(" 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 "),t("strong",[v._v("Monitor 锁")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("Monitor")]),v._v(" 是线程私有的数据结构，每一个线程都有一个可用 "),t("strong",[v._v("monitor record")]),v._v(" 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 "),t("strong",[v._v("monitor")]),v._v(" 关联，同时 "),t("strong",[v._v("monitor")]),v._v(" 中有一个 "),t("strong",[v._v("Owner")]),v._v(" 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。")]),v._v(" "),t("h3",{attrs:{id:"三、无锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、无锁"}},[v._v("#")]),v._v(" 三、无锁")]),v._v(" "),t("p",[v._v("无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。")]),v._v(" "),t("p",[v._v("无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。")]),v._v(" "),t("h3",{attrs:{id:"四、偏向锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、偏向锁"}},[v._v("#")]),v._v(" 四、偏向锁")]),v._v(" "),t("p",[v._v("偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。")]),v._v(" "),t("p",[v._v("当一个线程访问同步代码块并获取锁时，会在 "),t("strong",[v._v("Mark Word")]),v._v(" 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 "),t("strong",[v._v("CAS")]),v._v(" 操作来加锁和解锁，而是检测 "),t("strong",[v._v("Mark Word")]),v._v(" 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 "),t("strong",[v._v("CAS")]),v._v(" 原子指令，而偏向锁只需要在置换 "),t("strong",[v._v("ThreadID")]),v._v(" 的时候依赖一次 "),t("strong",[v._v("CAS")]),v._v(" 原子指令即可。")]),v._v(" "),t("p",[v._v("偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。")]),v._v(" "),t("p",[v._v("关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。")]),v._v(" "),t("p",[v._v("偏向锁在 "),t("strong",[v._v("JDK 6")]),v._v(" 及之后版本的 "),t("strong",[v._v("JVM")]),v._v(" 里是默认启用的。可以通过 "),t("strong",[v._v("JVM")]),v._v(" 参数关闭偏向锁："),t("strong",[v._v("-XX:-UseBiasedLocking=false")]),v._v("，关闭之后程序默认会进入轻量级锁状态。")]),v._v(" "),t("h3",{attrs:{id:"五、轻量级锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、轻量级锁"}},[v._v("#")]),v._v(" 五、轻量级锁")]),v._v(" "),t("p",[v._v("轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。")]),v._v(" "),t("p",[v._v("轻量级锁的获取主要由两种情况："),t("strong",[v._v("① 当关闭偏向锁功能时")]),v._v("；"),t("strong",[v._v("② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁")]),v._v("。")]),v._v(" "),t("p",[v._v("在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机将首先在当前线程的栈帧中建立一个名为锁记录（"),t("strong",[v._v("Lock Record")]),v._v("）的空间，用于存储锁对象目前的 "),t("strong",[v._v("Mark Word")]),v._v(" 的拷贝，然后将对象头中的 Mark Word 复制到锁记录中。")]),v._v(" "),t("p",[v._v("拷贝成功后，虚拟机将使用 "),t("strong",[v._v("CAS")]),v._v(" 操作尝试将对象的 "),t("strong",[v._v("Mark Word")]),v._v(" 更新为指向 "),t("strong",[v._v("Lock Record")]),v._v(" 的指针，并将 "),t("strong",[v._v("Lock Record")]),v._v(" 里的 "),t("strong",[v._v("owner")]),v._v(" 指针指向对象的 "),t("strong",[v._v("Mark Word")]),v._v("。")]),v._v(" "),t("p",[v._v("如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 "),t("strong",[v._v("Mark Word")]),v._v(" 的锁标志位设置为 "),t("strong",[v._v("“00”")]),v._v("，表示此对象处于轻量级锁定状态。")]),v._v(" "),t("p",[v._v("如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 "),t("strong",[v._v("Mark Word")]),v._v(" 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。")]),v._v(" "),t("p",[v._v("若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。")]),v._v(" "),t("p",[v._v("另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。")]),v._v(" "),t("h3",{attrs:{id:"六、重量级锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、重量级锁"}},[v._v("#")]),v._v(" 六、重量级锁")]),v._v(" "),t("p",[v._v("重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。")]),v._v(" "),t("p",[v._v("重量级锁通过对象内部的监视器（"),t("strong",[v._v("monitor")]),v._v("）实现，而其中 "),t("strong",[v._v("monitor")]),v._v(" 的本质是依赖于底层操作系统的 "),t("strong",[v._v("Mutex Lock")]),v._v(" 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。")]),v._v(" "),t("p",[v._v("简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。")]),v._v(" "),t("h3",{attrs:{id:"七、关于自旋"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、关于自旋"}},[v._v("#")]),v._v(" 七、关于自旋")]),v._v(" "),t("p",[v._v("关于自旋，简言之就是让线程喝杯咖啡小憩一下，用代码解释就是：")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("do")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// do something")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("while")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("自旋的规则，或者说自旋的次数"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),t("p",[v._v("引入自旋这一规则的原因其实也很简单，因为阻塞或唤醒一个 "),t("strong",[v._v("Java 线程")]),v._v("需要操作系统切换 "),t("strong",[v._v("CPU")]),v._v(" 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。并且在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，这部分操作的开销其实是得不偿失的。")]),v._v(" "),t("p",[v._v("所以，在物理机器有多个处理器的情况下，当两个或以上的线程同时并行执行时，我们就可以让后面那个请求锁的线程不放弃 "),t("strong",[v._v("CPU")]),v._v(" 的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋。如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。")]),v._v(" "),t("p",[v._v("自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。")]),v._v(" "),t("p",[v._v("所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用 -XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。")]),v._v(" "),t("p",[v._v("自旋锁在 "),t("strong",[v._v("JDK1.4.2")]),v._v(" 中引入，使用 "),t("strong",[v._v("-XX:+UseSpinning")]),v._v(" 来开启。"),t("strong",[v._v("JDK 6")]),v._v(" 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。")]),v._v(" "),t("p",[v._v("自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。")]),v._v(" "),t("p",[v._v("八、总结\n偏向锁通过对比 "),t("strong",[v._v("Mark Word")]),v._v(" 解决加锁问题，避免执行 "),t("strong",[v._v("CAS")]),v._v(" 操作。")]),v._v(" "),t("p",[v._v("轻量级锁是通过用 "),t("strong",[v._v("CAS")]),v._v(" 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。")]),v._v(" "),t("p",[v._v("重量级锁是将除了拥有锁的线程以外的线程都阻塞。")]),v._v(" "),t("p",[v._v("参考：https://tech.meituan.com/2018/11/15/java-lock.html")]),v._v(" "),t("p",[v._v("本文转自：http://www.jetchen.cn/synchronized-status/")])])}),[],!1,null,null,null);_.default=s.exports}}]);